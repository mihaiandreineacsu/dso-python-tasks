import os
import subprocess
from logger import log_msg


def run_subprocess(
    args: str | bytes | os.PathLike,
    on_error_message: str = None,
    shell: bool = False,
    cwd: str = None,
    encoding: str = None,
    timeout: float = None,
    check: bool = False,  # Adds a check parameter to raise an exception if returncode is non-zero
    input: str = None,  # Adds input parameter to pass data to stdin
) -> subprocess.CompletedProcess[str]:
    """
    Wrapper function that calls subprocess.run with given arguments.

    Args:
        args (tuple) : Arguments to pass to subprocess.run.
        on_error_message (str) : Custom error message to log when subprocess fails.
        shell (bool) : Sets the shell flag of subprocess.run.
        cwd (str): The directory from which to run the command. Defaults to None.
        encoding (str): Specifies encoding for the output.
        timeout (float): Specifies timeout for subprocess.run.
        check (bool): If True, raise a CalledProcessError on non-zero exit code.
        input (str): Data to send to the subprocess' stdin.

    Raises:
        RuntimeError: When subprocess.run returns a non-zero exit code and check is False.
        subprocess.CalledProcessError: If check is True and a non-zero exit code occurs.

    Returns:
        subprocess.CompletedProcess[str] : Result of subprocess.run.
    """

    if shell:
        log_msg(f"Potential security risk: args {args} is running in shell!", "WARNING")

    try:
        # Pass the input argument if specified
        result = subprocess.run(
            args,
            capture_output=True,  # Capture stdout and stderr
            text=True,  # Treat stdout, stderr, and input as text (str)
            shell=shell,  # Run in shell if needed
            cwd=cwd,  # Working directory
            encoding=encoding,  # Encoding for input and output
            timeout=timeout,  # Timeout for the process
            input=input,  # Input data for stdin
            check=check,  # Raise error if command fails (non-zero exit code)
        )
        return result

    except subprocess.TimeoutExpired as e:
        raise RuntimeError(f"Subprocess timed out: {e}")

    except subprocess.CalledProcessError as e:
        if not on_error_message:
            on_error_message = str(args)
        raise RuntimeError(f"{on_error_message}: {e.stderr.strip()}")

    except Exception as e:
        raise RuntimeError(f"An unexpected error occurred: {str(e)}")
